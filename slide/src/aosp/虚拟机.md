### 解释执行和JIT
- **解释执行**分为简单的switch-case解释执行（译码分派）和线程代码（threaded code）。线程代码的本质就是每一条解释执行结束以后不回到整个大的while循环，而是直接取出程序所要运行的下一条指令，pc跳到该条指令处运行。其最重要的部分就是预取下一条指令。
```c
void interpret() {
  void* program[] = { &&l_add, &&l_sub /* ... */ };
  int* sp = ...;
  void** pc = program;
  goto **pc; /* jump to first instruction */
 l_add:
  sp[1] += sp[0];
  ++sp;
  goto **(++pc); /* jump to next instruction */
  /* ... other instructions */
 l_sub:
  ...;
  goto **(++pc); /* jump to next instruction */
  /* ... other instructions */
}
```
- **JIT**：JIT分为Method-Based JIT，Trace-Based JIT和Region-Based JIT。(Method是实例化的对象中的函数，function是类中定义的函数)可以将由JIT编译器编译的某段代码认为是一个super instuction。
	举一个**super instruction**的例子，通常需要通过四条java字节码才能完成为变量加上一个常量的操作（例子如下）。而如果这是一个常用的方法，我们就可以用一个unused bytecode作为super instruction来表示这四条指令的操作（个人理解为解释器版的vtable），这样解释器可以通过运行一条super instruction来达到完成运行四条字节码的效果，局部将基于栈的指令实现为基于寄存器指令的效果。因为指令槽有限，unused bytecode有限，所以需要通过分析不同的workload来确定最高效的字节码组合来组成super instruction。
		**问**：是否能实现**dynamic super instruction**来加速解释执行？
```java
//var_1 = var_2 + 2;
1: iload_1 ; push variable 1 on stack
2: iconst_2 ; push constant 2 on stack
3: iadd ; add the stack top two items
4: istore_1 ; pop stack and store to variable 1
```
1. **Method-Based JIT**：其中关键的数据结构是vtable。**vtable**是一张用于存放多个虚函数的表，其是一个指针数组，存储了虚拟方法的地址。调用函数的时候可以通过对vtable进行地址偏移来选取对应的函数。每次调用method就可以快速的根据vtable来调用。注：Method-Based JIT默认编译所有冷热代码。
	pseudocode如下：
```c++
vtable = *ovar;// Get vtable pointer from ovar pointer
foo_funcptr = *(vtable + foo_offset); //get pointer to foo()
(*foo_funcptr)(); //invoke foo()
```
如果方法未经JIT compiler编译需要跳入trampoline进行编译。首先将method数据结构简化版的trampoline如下：
```c++
pushl $0x7001234 //address of foo()’s description
call $0x7005678 //address of jit_compile(method)
jmp %eax //eax holds the compiled code entry address
```
trampoline首先将virtual method（即实例化的对象中的虚函数）`foo()`的数据结构（即包含各种传入参数）的地址压入栈中，此时runtime stack就有了传入参数以及返回地址ra，有了这些参数通过调用`jit_compile()`来将方法编译为machine code，下一次调用该方法时候便可以直接调用编译过的machine code（相当于一条super instruction）来加速执行。
2. **Trace-Based JIT**：为了减少编译时间和空间浪费，Traced-Based JIT只根据运行时热度编译特定路径上的代码。Trace-Based JIT主要有三个任务：1. 确定trace。2. 编译并缓存trace路径上的代码。 3. 自适应管理trace。为了分析代码热度一般在潜在的trace入口插入计数器进行计数，当计数器达到一个阈值时便可认为该trace为热路径。通常有三个地方可以作为潜在的trace入口用于插入计数器：一个method prolog（方法前序）；循环头；basic block（基本块）（具体如何描述？）
		dalvik VM就在基本块（basic block）层面对代码进行热度分析。其在每一个单独最大的基本块中插入计数器。这里的基本块是一个编译器术语，指的是具有单个入口点和出口点的代码段。最大基本块即再插入任何指令其就不能成为一个基本块。
	对于basic-block-based tracing，基本块可以被chained来避免涉及运行时服务和解释器。链接的过程就是当知道一个trace退出后会进入另一个trace，那么控制流就可以直接转换到下一个trace。链接的trace可以形成一个trace树或trace图。
	loop-based traceing有一个好处就是只要方法在循环跟踪的路径中，其就可以自动内联方法。而basic-block-based tracing通常不会贯穿整个方法（除非该方法十分简单只需要一次跳转）
3. **Region-Based JIT**：Region-based JIT可以被认为是method-based JIT和trace-based JIT的混合体。类似于更小细粒度的method-based JIT。有时编译整个方法会造成不必要的开销，该JIT便可以选择性的编译代码的特定区域，这些区域通常是在程序运行时经常执行的热点代码路径。
		对于类似Java的静态类型语言，region-based JIT可以通过禁止编译整个method的方式来使其能在内存受限的平台上良好的工作。对于动态类型语言，region-based JIT可以使用类型专用化来避免跟踪扩展（trace explosion）dalvik VM在一定程度上就可以认为是region-based JIT。

### 本地接口JNI
JNI为Java方法提供了一个接口来调用本地方法，要完成本地方法的调用，本地方法必须被调用的Java类声明为native，在编译声明有本地方法调用的Java类之后，它就被传给javah程序，javah将为本地方法产生一个头文件。然后头文件和本地方法代码可以被编译以形成可调用的本地方法。
#### 一、背景
- 为了访问底层系统资源和VM服务，高级语言需要在其VM中实现本地接口。
	- **安全原因**：高级语言不允许直接操纵内存地址、机器指令和IO接口等资源，当程序需要处理底层逻辑或者需要提供高性能时这些访问是必要的。
	- **可移植性**：高级语言本质上是平台无关的，要访问平台特定的功能，比如文件系统，它就需要使用平台的本地语言。
	- **实现原因**：有些库只有本地语言的实现可用，比如没有移植到高级语言或者只在遗留实现中存在的媒体库。
- 本地接口涉及具有以下属性：
	- **本地语言**：该语言需要为高级语言提供可以访问底层硬件或系统资源的本地接口。
	- **本地（低级语言）代码<->托管（高级语言）代码**：不仅需要高->低，低->高也是需要的，因此可以从OS访问VM系统，或者从本地代码回调到高级代码。
	- **数据共享**：高低级代码之间创建的数据应该能够实现共享。
#### 二、managed code -> native code
本地接口的首要需求是支持托管代码调用本地代码，以及反向调用。关键点是在两个世界之间达成一个调用惯例共识。调用惯例定义了**如何传递参数和返回值，以及如何准备和恢复栈（ABI）**。有时还需要维护支持调试、异常处理和垃圾回收需求的栈帧信息。为了支持JNI，JVM应该了解C的调用惯例。
##### 本地方法封装（Wrapper for Native Method）
- JIT编译器在编译调用方的Java语言代码时，生成一条到**封装代码（可以将JNI_trampoline看为wrapper code的一种具体实现**）的调用指令，然后封装代码调用到实际的本地代码。封装代码对Java语言调用方遵循Java语言调用惯例，对本地被调用方遵循本地调用惯例。为了实现桥接，特别是对Java语言调用方来说，本地方法要看起来就像是一个Java语言方法，它需要做以下几件事情：
	- 参数准备与恢复、栈展开（stack unwinding）支持、垃圾回收支持、**异常支持**、**同步支持**。
- JVM中实例方法调用（字节码invokevirtual）的第一个参数是当前实例引用this，它是被调用方栈帧上位于槽位0的局部变量。参数this在实例方法签名定义中不是显式的，对静态java方法调用来说，jvm没有这种隐式参数。对本地方法调用来说，JVM要求虚拟本地方法像java一样把this引用作为参数传递，而静态本地方法要求传递类实例引用，此外还需要传递一个JNI环境变量，其中存储了一个所有JNI API的函数表，以支持本地方法访问所有需要的JVM资源。
- **下面是一个展示封装支持的示例**：静态方法调用（字节码invokestatic）实际上是用一条到目标本地方法native_add()的封装代码的调用实现的。JIT编译器以与调用静态Java方法相同的方式为invokestatic生成代码，只不过调用目标变成了封装代码。
```java
// Java代码中的Java方法
public class Add{
    public static native int native_add(int x, int y);
    public static int java_add(int x, int y);
    public static int add(int x, int y){
        return native_add(x, y);
    }
}
// add(x, y)生成字节码
0: iload_0
1: iload_1
2: invokestatic #2 // 调用静态方法native_add，这里#2是对native_add方法的符号引用，常量池索引占2个字节
5: ireturn
```
- **封装代码看见的栈**。控制流进入封装代码后就像进入了静态Java方法一样。**java参数从左到右压栈**：
```bash
+---------------+
|   high addr   |
|      ...      |
+---------------+ <---- 帧指针fp
|       x       |
+---------------+
|       y       |
+---------------+
|   return PC   |
+---------------+ <---- 栈指针sp
|      ...      |
|   low addr    |
+---------------+
```
- **本地方法**native_add(x, y)应该用如下定义实现，其相当于wrapper code的一部分：
```c++
JNIEXPORT jint JNICALL Java_Add_native_1add(JNIEnv *, jclass, jint, jint);
```
- **本地代码实际的栈**：C方法参数从右到左压栈。
```bash
+---------------+
|   high addr   |
|      ...      |
+---------------+ <---- 帧指针fp
|       y       |
+---------------+
|       x       |
+---------------+
|   class Add   |
+---------------+
|    JNI env    |
+---------------+ <---- 栈指针sp
|      ...      |
|   low addr    |
+---------------+
```
- 封装代码所需要做的就是将栈上数据合并起来，在这个JNI实现中，Java调用方原本准备的栈仍然保存完好，将在封装代码返回时被清理。
```bash
+---------------+
|   high addr   |
|      ...      |
+---------------+ <---- Java方法帧指针fp
|       x       |
+---------------+
|       y       |
+---------------+
|   return PC   |
+---------------+ <---- Java方法栈指针sp/本地方法帧指针fp
|       y       |
+---------------+
|       x       |
+---------------+
|   class Add   |
+---------------+
|    JNI env    |
+---------------+ <---- 本地方法栈指针sp
|      ...      |
|   low addr    |
+---------------+
```
- 以上只是简化版本的封装，真实处理中还需要保存**被调用方保存寄存器**（callee-saved register/call-clobbered/s(aved)0-s11 in riscv）。为了支持同步还会在执行本地方法前后插入monitorenter和monitorexit，此处不展开讨论。
#### 三、native code->managed code
- 本地方法能够操作Java方法生成的对象，包括数据访问和方法调用，JNI规范提供了用于本地方法调用Java方法的API，这些API应该由JVM实现：
```c
jint JNICALL CallStaticIntMethod(JNIEnv* jenv, jclass clazz, jmethodID method, ...)
```
- 这个API允许本地代码用可变参数调用某个类clazz的static方法method，返回值为jint。它的函数指针注册在JNI环境变量jenv中，本地代码可以在其中找到这个函数指针。下面给出一段从本地方法调用Java方法的示例代码。为了支持此类API，JVM所做的就是准备参数，调用Java方法，读取返回值，检查Java方法执行是否抛出任何异常等。
	- native code -> managed code**不需要为每个Java方法生成封装，因为从本地代码转换到Java的逻辑较为简单，这是因为Java方法信息不可知，所以只能在运行时使用Java的反射机制和JNI API来调用方法**。
	- managed code->native code：**需要为每个本地方法生成封装**，因为如果对所有本地方法都使用同一种封装代码，那么它就必须编入逻辑检查来确定目标本地方法是否为静态，是否为同步，检查参数数量和类型等等，然后根据不同的情况进入不同的路径，这样的话就会造成很大的开销。因为**本地方法相关信息在编译时就可知**，就可以为每个本地方法建立一个单独的封装代码，用空间来换时间。
```c
// 本地方法Add.native_1add()调用Add.java_add()
JNIEXPORT jint JNICALL Java_Add_native_add(JNIEnv *jenv, jclass clazz, jint x, jint y)
{
    jmethodID mid = (*jenv) -> GetStaticMethodID(jenv, clazz, "java_add", "2");
    int sum = (*jenv)->CallStaticIntMethod(jenv, clazz, mid, x, 0);
    return sum;
}
```
- 当JVM运行时收到对CallStaticIntMethod这样的JNI API调用时，它会基于Java语义执行一些必要检查，然后调用一段trampoline代码。
```c
void native_to_java_call(void *java_entry,
						 uint32 n_arg_words, uint32 *p_args_words,
						 uint32 *p_eax_var, uint32 *p_edx_var)
{
	__asm {
	// Push all arguments
	mov n_arg_words -> ecx
	mov p_arg_words -> eax
	
loop_more_args:
	or ecx, ecx //remaining # arg words
	jz finished_args //break if no more
	push dword ptr [eax] //push a word
	dec ecx //decrement remaining #
	add 4 -> eax //move to next arg word
	jmp loop_more_args //loop back to continue

finished_args:
	// All arguments are on the stack, ready to call
	call dword ptr [meth_addr]
	
	// In case a value is returned
	mov p_eax_var -> ecx
	mov eax -> [ecx] //store eax to eax_var
	mov p_edx_var -> ecx
	mov edx -> [ecx] //store edx to edx_var
	}
}
```
### 栈展开（stack unwinding）
#### 一、背景
栈展开主要有两个应用场景，一个用于**控制流转移（一般用于异常处理）**，另一个用于栈内容检查。
- 控制流由线程上下文决定，线程上下文至少包含栈指针和程序计数器。